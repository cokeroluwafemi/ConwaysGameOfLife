// Conway's Game of Life
// Steven Klise <http://stevenklise.com>
// 2011

// Based on: Conway's Game of Life, by Mike Davis. 

// Grid resizes based on window (jQuery)

// TODO:
// - Control Panel
// - Speed variance.

Grid board;
//boolean running;
int[][][] world;
boolean kill = false;

HashMap forms = new HashMap();

void setup()
{
	size(window.sketchWidth, window.sketchHeight);
	frameRate(window.speed);
	board = new Grid(3, 45, width-3, height-3, 10);
	window.running = false;

	world = new int[board.gw][board.gh][2];
	
	forms.put("GLIDER","0,0,1,1,0,1,0,1,1");
	forms.put("BLINKER","0,1,0,0,1,0,0,1,0");
	forms.put("R-PENTOMINO","0,1,1,1,1,0,0,1,0");
	forms.put("BEACON","1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,1");
	forms.put("TOAD","0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0");
	forms.put("HERSCHEL","1,0,0,0,1,1,1,0,1,0,1,0,0,0,1,0");
	forms.put("BLOCK","1,1,0,1,1,0,0,0,0");
	forms.put("AIRCRAFT CARRIER","1,1,0,0,1,0,0,1,0,0,1,1,0,0,0,0");
	forms.put("BEEHIVE","0,1,1,0,1,0,0,1,0,1,1,0,0,0,0,0");
	forms.put("BOAT","1,1,0,1,0,1,0,1,0");
	forms.put("LOAF","0,1,1,0,1,0,0,1,0,1,0,1,0,0,1,0");
	forms.put("LIGHTWEIGHT SPACESHIP","0,1,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0");
}

void draw()
{
	background(0);
	board.render();
	frameRate(window.speed);
	for (int x=0; x<board.gw; x++) // draw and update.
	{
		for (int y=0; y<board.gh; y++)
		{
			if (world[x][y][0] == 1)
			{
				PVector l = board.toScreen(x, y);
				rect(l.x, l.y, board.res, board.res);
			}
			int n = neighbors(x, y);
			if ((n < 2 || n > 3) && world[x][y][0] == 1)
			{
				world[x][y][1] = -1;
			}
			else if (n == 3 && world[x][y][0] == 0)
			{
				world[x][y][1] = 1;
			}
			else
			{
				world[x][y][1] = 0;
			}
		}
	}
	if (window.running)
	{
		for (int x=0; x<board.gw; x++)
		{
			for (int y=0; y<board.gh; y++)
			{
				if (world[x][y][1] == 1 || (world[x][y][1] == 0 && world[x][y][0] == 1))
				{
					world[x][y][0] = 1;
				}
				else if (world[x][y][1] == -1)
				{
					world[x][y][0] = 0;
				}
			}
		}
	}
	ifClear();
}

void ifClear() // Function to clear the entire world.
{
	if(window.cclear)
	{
		for (int x=0; x<board.gw; x++)
		{
			for (int y=0; y<board.gh; y++)
			{
				world[x][y][0] = 0;
				world[x][y][1] = 0;
			}
		}
		window.cclear = false;
	}
}

void mouseDragged() // dragging the mouse is different than clicking. Requires mousePressed() for initial condition.
{
	if (mouseX > board.tx && mouseX < board.bx && mouseY < board.by && mouseY > board.ty)
	{
		PVector t = board.toGrid(mouseX, mouseY);
		if (!kill)
		{
			world[(int)t.x][(int)t.y][0] = 1;
		}
		else
		{
			world[(int)t.x][(int)t.y][0] = 0;
		}
	}
}

void mousePressed() // Did the user press on a live or dead cell?
{
	if (mouseX > board.tx && mouseX < board.bx && mouseY < board.by && mouseY > board.ty)
	{
		PVector l = board.toGrid(mouseX, mouseY);
		if (world[(int)l.x][(int)l.y][0] != 1)
		{
			kill = false;
		}
		else
		{
			kill = true;
		}
	}
}

void mouseClicked() // Single cell birth or death, as well as placing forms.
{
	if (mouseX > board.tx && mouseX < board.bx && mouseY < board.by && mouseY > board.ty)
	{
		PVector l = board.toGrid(mouseX, mouseY);
		if (mouseButton == LEFT)
		{
			if(window.cforms != undefined)
			{
				placeForm(window.cforms, (int)l.x,(int)l.y);
			}
			else
			{
				world[(int)l.x][(int)l.y][0] = (world[(int)l.x][(int)l.y][0]+1)%2;
			}
		}
	}
}

int neighbors(int x, int y)
{
	if(window.edges)
	{
		int n =0;
		if (x+1 < board.gw)
		{
			n += world[(x + 1)][y][0];
			if (y+1 < board.gh)
			{
				n += world[(x + 1)][(y + 1)][0];
			}
			if (y-1 >= 0)
			{
				n += world[(x + 1)][(y - 1)][0];
			}
		}
		if (x-1 >= 0)
		{
			n += world[(x - 1) % board.gw][y][0];
			if (y+1 < board.gh)
			{
				n += world[(x - 1)][(y + 1)][0];
			}
			if (y-1 >= 0)
			{
				n += world[(x - 1)][(y - 1)][0];
			}
		}
		if (y-1 >= 0)
		{
			n += world[x][(y - 1)][0];
		}

		if ( y+1 < board.gh )
		{
			n += world[x][(y + 1)][0];
		}
		return n;
	}
	else
	{
		return world[(x + 1) % board.gw][y][0] + 
			world[x][(y + 1) % board.gh][0] + 
			world[(x + board.gw - 1) % board.gw][y][0] + 
			world[x][(y + board.gh - 1) % board.gh][0] + 
			world[(x + 1) % board.gw][(y + 1) % board.gh][0] + 
			world[(x + board.gw - 1) % board.gw][(y + 1) % board.gh][0] + 
			world[(x + board.gw - 1) % board.gw][(y + board.gh - 1) % board.gh][0] + 
			world[(x + 1) % board.gw][(y + board.gh - 1) % board.gh][0];
	}
}


class Grid
{
	int tx;
	int ty;
	int bx;
	int by;
	int gw;
	int gh;
	int res;

	Grid(int _tx, int _ty, int _bx, int _by, int _res)
	{
		tx = _tx; 
		ty = _ty; 
		bx = _bx; 
		by = _by; 
		res = _res;
		gw = int((bx-tx)/res);
		gh = int((by-ty)/res);
	}

	void render()
	{
		stroke(60,60,60,255);
		for (int x=tx; x<=bx; x += res)
		{
			line(x,ty,x,gh*res+ty);
		}
		for (int y=ty; y<=by; y += res)
		{
			line(tx,y,gw*res+tx,y);
		}
	}

	PVector toGrid(int x, int y) // Convert a pixel number to a grid number
	{
		int gridx = (x - tx)/res;
		int gridy = (y - ty)/res;
		PVector v = new PVector(gridx,gridy);
		return v;
	}

	PVector toScreen(int x, int y) // Convert a grid number to a pixel number
	{
		int sx = x*res+tx;
		int sy = y*res+ty;
		PVector v = new PVector(sx,sy);
		return v;
	}
}

void placeForm(String thisform, int x, int y)
{
	String rule = forms.get(thisform);
	int[] intvals = int(split(rule,','));
	int fx = x;
	int fy = y;
	if(intvals.length == 9)
	{
		world[fx][fy][0] = intvals[0];
		world[fx+1][fy][0] = intvals[1];
		world[fx+2][fy][0] = intvals[2];
		world[fx][fy+1][0] = intvals[3];
		world[fx+1][fy+1][0] = intvals[4];
		world[fx+2][fy+1][0] = intvals[5];
		world[fx][fy+2][0] = intvals[6];
		world[fx+1][fy+2][0] = intvals[7];
		world[fx+2][fy+2][0] = intvals[8];
	}
	else if(intvals.length == 16)
	{
		world[fx][fy][0] = intvals[0];
		world[fx+1][fy][0] = intvals[1];
		world[fx+2][fy][0] = intvals[2];
		world[fx+3][fy][0] = intvals[3];
		world[fx][fy+1][0] = intvals[4];
		world[fx+1][fy+1][0] = intvals[5];
		world[fx+2][fy+1][0] = intvals[6];
		world[fx+3][fy+1][0] = intvals[7];
		world[fx][fy+2][0] = intvals[8];
		world[fx+1][fy+2][0] = intvals[9];
		world[fx+2][fy+2][0] = intvals[10];
		world[fx+3][fy+2][0] = intvals[11];
		world[fx][fy+3][0] = intvals[12];
		world[fx+1][fy+3][0] = intvals[13];
		world[fx+2][fy+3][0] = intvals[14];
		world[fx+3][fy+3][0] = intvals[15];
	}
	else if(intvals.length == 25)
	{
		world[fx][fy][0] = intvals[0];
		world[fx+1][fy][0] = intvals[1];
		world[fx+2][fy][0] = intvals[2];
		world[fx+3][fy][0] = intvals[3];
		world[fx+4][fy][0] = intvals[4];
		world[fx][fy+1][0] = intvals[5];
		world[fx+1][fy+1][0] = intvals[6];
		world[fx+2][fy+1][0] = intvals[7];
		world[fx+3][fy+1][0] = intvals[8];
		world[fx+4][fy+1][0] = intvals[9];
		world[fx][fy+2][0] = intvals[10];
		world[fx+1][fy+2][0] = intvals[11];
		world[fx+2][fy+2][0] = intvals[12];
		world[fx+3][fy+2][0] = intvals[13];
		world[fx+4][fy+2][0] = intvals[14];
		world[fx][fy+3][0] = intvals[15];
		world[fx+1][fy+3][0] = intvals[16];
		world[fx+2][fy+3][0] = intvals[17];
		world[fx+3][fy+3][0] = intvals[18];
		world[fx+4][fy+3][0] = intvals[19];
		world[fx][fy+4][0] = intvals[20];
		world[fx+1][fy+4][0] = intvals[21];
		world[fx+2][fy+4][0] = intvals[22];
		world[fx+3][fy+4][0] = intvals[23];
		world[fx+4][fy+4][0] = intvals[24];
	}
}